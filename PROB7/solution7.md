#波兰表达式

###基本思路

没什么可说的，建立二叉树，我们将每个二元运算符看作是一个函数【例如a*b看做operator*(a, b)】。
这样的话，每个运算符看做一个节点，其两个子节点就是参数或子表达式。
例如：1*3+2可以化作如下树结构：

           +
         /   \
       *      2
      /   \
      1   3


###运算符是有优先级的。如何实现呢？

就拿刚才的表达式为例，我们可以用一个数组做优先级排序，优先级越高，排序越靠后。
例如加减乘除的优先级数组为{'+', '-', '*', '/'}
然后遍历整个串，如果没有'+'，就看看有没有'-'，然后有没有'*'……以此类推。
如果先找到了某个运算符，就暂时忽略其他运算符。
将这个运算符看作是将整个表达式一劈两半，左边是左子串，右边是右子串。

然后递归，找出子串中的子串，并加在节点的左子树和右子树。

如果串里没有运算符怎么办？
用一个布尔值hasNoOp记录有没有检索到运算符。
如果没找到，情况只有一种：这就是个数字。

###括号的问题

刚才提到的运算符优先级问题上其实还有个漏洞，那就是括号。
令人费解的是题目给出的示例就是有问题的。波兰表达式不可能有括号。

其实，我们可以将括号看做一种“屏蔽”。它将串中的部分子串给“屏蔽”起来，意思可以看做“暂时不要管这里面的任何运算符”。
所以，不嫌麻烦的话，就建立一个与串等长的布尔数组，标记一下哪些子串是在括号中的，那么我们检索运算符时，凡是括号中的运算符是不考虑的。
所以，只有最外层的运算符有效。

<del>如果表达式整个被括号包起来了怎么办？把两端的括号消掉！</del>
好吧，当我没说上面那句话，看来还是得把整个串遍历一遍确定是否最外层有运算符……
例如：(1+2)/(3+4)用上面的方法就会变成：1+2)/(3+4，错误。

<code>
while (expression[0] == '(' && expression[expression.length() - 1] == ')') {
  expression = expression.substr(1, expression.length() - 2);
}
</code>


###获得波兰表达式和逆波兰表达式

详见Main.cpp中的getPolishExp(ExpNode* node)和string getPolishExpRev(ExpNode* node)。
